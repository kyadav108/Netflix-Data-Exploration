# -*- coding: utf-8 -*-
"""Netflix_Case_Study.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FFrRbaK9wA7pb5Nua27-kYAoTnaqwfre
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

!gdown https://d2beiqkhq929f0.cloudfront.net/public_assets/assets/000/000/940/original/netflix.csv

df=pd.read_csv("netflix.csv")

"""**Data Exploration**


"""

df.shape

"""df.shape shows that initially DataFrame had 8807 rows and 12 columns."""

df.info()

"""## 1. Find the counts of each categorical variable both using graphical and non-graphical analysis

Here we can observe,the dataframe consists of 12 columns. Each column's data type is object, except for the release_year column. The count of non-null values is provided for each column.
"""

df.isnull().sum()

"""The df.isnull().sum() method returns the number of null values in each column. The results are as follows:

1. The director column has 2,634 null values.
2. The cast column has 825 null values.
3. The date_added column has 10 null values.
4. The rating and duration columns have 4 and 3 null values, respectively.
"""

import seaborn as sns
import matplotlib.pyplot as plt

df.nunique()

df_dict=dict(df.nunique())
df_dict

plt.figure(figsize=(8,6))
plt.bar(df_dict.keys(), df_dict.values())
plt.title('Count of Columns(Unique Values)')
plt.xlabel('Category',size=17)
plt.ylabel('Count Of Values',size=10)
plt.xticks(rotation=45)
plt.show()

df_info=df.info()

dt= {
    'Column': ['show_id', 'type', 'title', 'director', 'cast', 'country', 'date_added', 'release_year', 'rating', 'duration', 'listed_in', 'description'],
    'Value_count': [8807, 8807, 8807, 6173, 7982, 7976, 8797, 8807, 8803, 8804, 8807, 8807]
}
pd.DataFrame(dt).head(5)

plt.figure(figsize=(8,6))
plt.bar(dt["Column"], dt["Value_count"])
plt.title('Count of Columns')
plt.xlabel('Category',size=12)
plt.ylabel('Count Of Values',size=12)
plt.xticks(rotation=45)
plt.show()

df.sample(5)

"""By examining the dataframe, we can see that the director, cast, country, and listed_in columns contain multiple entries within a single row

## Data Cleaning

1. Splitting Multiple Entries into Separate Rows:

---
"""

df_director_r=pd.DataFrame(df["director"].apply( lambda x: str(x).split(",")).tolist(),index=df["title"])
df_director=df_director_r.stack().reset_index()
df_director.drop("level_1", axis=1, inplace=True)
df_director.rename(columns={0:"director"}, inplace=True)

df_director.sample(5)

"""2. Unnesting column cast."""

df_director["director"].nunique()

"""I'm removing extra spaces,to prevent duplicate values caused by extra spaces in director column."""

df_director["director"] = df_director["director"].str.strip().str.replace(r'\s+', ' ', regex=True)

df_director["director"].nunique()

"""Splitting Multiple Entries into Separate Rows:"""

df_cast_r=pd.DataFrame(df["cast"].apply(lambda x:str(x).split(",")).tolist(), index=df["title"])
df_cast=cast=df_cast_r.stack().reset_index()
df_cast.drop("level_1", axis=1, inplace=True)
df_cast.rename(columns={0:"cast"},inplace=True)
df_cast

df_cast["cast"].nunique()

df_cast["cast"].unique()

df_cast["cast"] = df_cast["cast"].str.strip().str.replace(r'\s+', ' ', regex=True)

df_cast["cast"].nunique()

"""2. Creating new dataframe new_df by merging datafram director and dataframe
cast.

"""

new_df=df_director.merge(df_cast, on="title", how="left")

new_df.head(5)

"""Finally, merging columns of datafran new_df director and cast into our final DataFrame, df_final."""

df_final=new_df.merge(df[["title","show_id", "type","country", "date_added", "release_year",	"rating","duration",	"listed_in",	"description"]], on="title", how="left")

df_final.sample(5)

df_final.shape

"""**Similary Unnesting rows of column Country and listed_in.**"""

df_country_r=pd.DataFrame(df_final["country"].apply(lambda x:str(x).split(",")).tolist(), index=df_final["title"])
df_country=df_country_r.stack().reset_index()
df_country.drop("level_1",axis=1,inplace=True)
df_country.rename(columns={0:"country"},inplace=True)

df_country.nunique()

df_country['country'] = df_country['country'].str.strip().str.replace(r'\s+', ' ', regex=True)

df_country.nunique()

"""Merging columns of datafram df_country into datafram df_final"""

df_final=df_country.merge(df_final[["title",	"director",	"cast", "show_id",	"type", "date_added",	"release_year",	"rating",	"duration",	"listed_in","description"]],on="title",how="left")

df_final.shape

"""Deleting duplicate rowf from df_final."""

df_final[df_final.duplicated()]

df_final.drop_duplicates(inplace=True)

df_final.shape

df_final.nunique()

df_final.isna().sum()

"""Spliting nested rows."""

df_lst_r=pd.DataFrame(df_final["listed_in"].apply(lambda x:str(x).split(",")).tolist(), index=df_final["title"])
df_lst=df_lst_r.stack().reset_index()
df_lst.drop("level_1",axis=1,inplace=True)
df_lst.rename(columns={0:"listed_in"},inplace=True)
df_lst.sample(10)

"""Mrging column of df_lst to final_df."""

df_lst['listed_in'] = df_lst['listed_in'].str.strip().str.replace(r'\s+', ' ', regex=True)

df_final=df_lst.merge(df_final[["title",	"country","director",	"cast",	"show_id",	"type", "date_added",	"release_year",	"rating",	"duration",	"description"]],on="title",how="inner")

df_final.sample()

df_final.shape

df_final.drop_duplicates(inplace=True)

df_final.shape

"""After splitting all nested rows, merging them together, and deleting duplicate rows, df_final has 202010 rows and 12 columns.**bold text**

## Handling null values and correcting data types

Date column "date_added" have datatype object, so here converting it to datetime.
"""

df_final["date_added"] = pd.to_datetime(df_final["date_added"], errors='coerce')

df_final.sample()

df_final.info()

df_final.shape

"""Looking for null values."""

df_final.isna().sum()

"""The DataFrame df_final.isna() indicates that only the columns 'date_added', 'rating', and 'duration' have null values. Let's further confirm this by using value_counts()."""

df_final["country"].value_counts()

"""Here,we can see column country have 11897 nan values.

Steps for replacing null values:

1. Replace string 'nan' with NaN.
2. Define a function to fill null values with the country of the director.
3. If a director has multiple countries, take the mode and return it.
   otherwise, return "Not Available"
"""

df_final["country"].replace("nan",np.nan, inplace=True)

def solve(director_name):
  director_country = df_final[df_final['director'] == director_name]["country"].mode()
  if not director_country.empty:
    return director_country.iloc[0]

  return "Not Available"

df_final["country"]=df_final.apply(lambda x:solve(x["director"]) if pd.isna(x["country"]) else x["country"],axis=1)

"""Similarly checking values of columns director and cast."""

df_final["director"].value_counts()

df_final["cast"].value_counts()

"""Replacing nan value of column director and cast."""

df_final["director"].replace(['nan'],['Unknown director'], inplace=True)
df_final["cast"].replace(['nan'],['Unknow actor'], inplace=True)

df_final["director"].value_counts()

df_final["cast"].value_counts()

"""Column duration have 3 null values.


"""

df_final["duration"].value_counts()

df_final[df_final["duration"].isna()]

df_final.loc[[2438885,2527139,2528281],"duration"]=['74 min','84 min','66 min']

df_final["duration"].isna().sum()

df_final.loc[[2438885,2527139,2528281]]

"""We can observe that the "rating" column has incorrect values at indices [2438885, 2527139, 2528281]. Hence, I will remove those values.


"""

df_final.loc[[2438885,2527139,2528281],"rating"]=np.nan

df_final["rating"].isna().sum()

df_final["rating"].fillna('Not Available', inplace=True)

df_final["rating"].value_counts()

df_final.sample(10)

"""Column "date_added have 158 null values.
Replacing ithe null values with "Not Available".
"""

df_final.isna().sum()

df_final["date_added"].fillna('Not Available', inplace=True)

df_final.isna().sum()

"""Now, I have the DataFrame as desired for further analysis.

## Question 2: Comparison of tv shows vs. movies.
"""

df_final.sample()

df_movies=df_final[df_final["type"]=="Movie"]
df_movies.head(5)

"""Top 10 Countries, who produce most movies.




"""

top_10_contry_movies=df_movies.groupby("country")["title"].nunique().sort_values(ascending=False).reset_index()[:10]

top_10_contry_movies.rename(columns={"title":"movie_count"}, inplace=True)
top_10_contry_movies

fig = plt.figure(figsize=(8,6))

sns.barplot(data=top_10_contry_movies, x="country", y="movie_count")
plt.xlabel("Countries")
plt.ylabel("Movie Count")
plt.title("Top 10 Countries by Movie Production")
plt.xticks(rotation=45)
plt.show()

"""**Obervation:**
* The graph illustrates that the United States produces the most movies, with
2840 films, followed by India with 1031, and the United Kingdom with 538 movies.

*   It can be observed that India and the United Kingdom combined produce approximately half the number of movies as the United States.

*  It can also be observed that india is the olny Asian country in this Top 10 list.

**Recommendations:**

*   United States tops the list because English-language movies are watched around the world and have a large audience.

*   India is also one of the biggest entertainment markets. If Indian movies can be dubbed and produced in different languages, they can reach a larger audience within the country and also internationally.

"""

df_tv=df_final[df_final["type"]=="TV Show"]
df_tv.head(5)

"""Top 10 Countries, who produce most TV Shows."""

top_10_contry_tv=df_tv.groupby("country")["title"].nunique().sort_values(ascending=False).reset_index()[:10]

top_10_contry_tv.rename(columns={"title":"tv_show_count"}, inplace=True)
top_10_contry_tv

"""
This shows that united states produce most movies."""

fig = plt.figure(figsize=(8,6))

sns.barplot(data=top_10_contry_tv, x="country", y="tv_show_count")
plt.xlabel("Countries")
plt.ylabel("Tv Show Count")
plt.title("Top 10 Countries by TV Show Production")
plt.xticks(rotation=45)
plt.show()

"""**Observation:**

*   The United States tops the list with a TV show production count of 1293, followed by the United Kingdom with 273 shows and Japan with 199.
*   It's noteworthy that the United States produced a significantly greater number of shows than the other top 10 countries.
*  In this list, India ranks sixth.
*  Both Japan and South Korea produce more TV shows than India.

**Recommendations **
* The United States has the largest TV show production because they cater to a global audience. One of the reasons for this is the high quality of content they produce, which can be consumed by a larger audience.
* Indian audiences have historically enjoyed movies more than TV serials, but in recent years, the trend has changed. People are now enjoying good TV shows and series.
* If Indian producers can produce high-quality content showcasing the diverse culture and different stories of India, they can not only captivate domestic but also international audiences. In doing so, Indian shows can compete with Japanese and Korean TV shows.

## 3. What is the best time to launch a TV show?
"""

df_final["month"]=df_final["date_added"].dt.month
df_final["month"] = df_final["month"].fillna(0).astype(int)

df_final['week_number'] = df_final['date_added'].dt.isocalendar().week

df_final.sample()

"""Best week for movies."""

df_movies=df_final[df_final["type"]=="Movie"]
df_movies.sample(5)

best_week=df_movies.groupby("week_number")["title"].nunique().reset_index()
best_week.rename(columns=({"title":"movie_count"}),inplace=True)

best_week.sort_values(by="movie_count",ascending=False).head(10)

"""Best week for Tv Shows."""

df_tvShow=df_final[df_final["type"]=="TV Show"]
df_tvShow.sample(5)

best_week_tv=df_tvShow.groupby("week_number")["title"].nunique().reset_index()
best_week_tv.rename(columns=({"title":"tvShow_count"}),inplace=True)

best_week_tv.sort_values(by="tvShow_count",ascending=False).head(10)

plt.figure(figsize=(16,8))

plt.subplot(1, 2, 1)

sns.lineplot(data=best_week, x="week_number", y="movie_count")
plt.xlabel('Week Number', fontsize=12,color="red")
plt.ylabel('Movie Count', fontsize=12,color="red")

xp=best_week["week_number"]
yp=best_week["movie_count"]
for i in range(len(yp)):
  plt.annotate(f"week:{xp[i]}",
              xy=(xp[i],yp[i]),
               horizontalalignment="left",fontsize=8)
plt.title('Movie Count by Week Number', color="red")

plt.subplot(1,2,2)
sns.lineplot(data=best_week_tv, x="week_number", y="tvShow_count")
plt.xlabel('Week Number',fontsize=12, color="red")
plt.ylabel('Tv Show Count',fontsize=12, color="red")
xp=best_week_tv["week_number"]
yp=best_week_tv["tvShow_count"]
for i in range(len(yp)):
  plt.annotate(f"week:{xp[i]}",
              xy=(xp[i],yp[i]),
               horizontalalignment="left",fontsize=8)

plt.title('Tv Show Count by Week Number', color="red")
plt.show()

"""**Observation:**

* The graph indicates that weeks 1,9, 13, 18, 26, 31, 35, 40, and 44 are the optimal weeks to release movies. Considering that this year's weeks coincide with the last weeks of the month, we can conclude that the last week of the month is the best time to release a movie.

*   The graph indicates that weeks 27, 31, 24, 35, 13, 40, and 26 are the optimal weeks to release TV shows.

*   Week numbers 37, 31, 24, and 35 fall within June, while weeks 35, 40, and 44 correspond to September and October. Therefore, we can conclude that for TV shows, summer and festive times are the best periods for release.

Best month to release the Tv-show or the movie
"""

# Best month to release movies
best_month=df_movies.groupby("month")["title"].nunique().reset_index()
best_month.rename(columns=({"title":"movie_count"}),inplace=True)

best_month.sort_values(by="movie_count",ascending=False)

# Best month to release Tv Show
best_month_tv=df_tvShow.groupby("month")["title"].nunique().reset_index()
best_month_tv.rename(columns=({"title":"tvShow_count"}),inplace=True)

best_month_tv.sort_values(by="tvShow_count",ascending=False)

plt.figure(figsize=(16,8))

plt.subplot(1, 2, 1)

sns.lineplot(data=best_month, x="month", y="movie_count")
plt.xlabel('Month', fontsize=12,color="red")
plt.ylabel('Movie Count', fontsize=12,color="red")

yp=best_month["movie_count"]
for i in range(len(yp)):
  plt.annotate(f"month:{xp[i]}",
              xy=(xp[i],yp[i]),
               horizontalalignment="center",fontsize=8)
plt.title('Movie Count by Month', color="red")

plt.subplot(1,2,2)
sns.lineplot(data=best_month_tv, x="month", y="tvShow_count")
plt.xlabel('Month',fontsize=12, color="red")
plt.ylabel('TV Show Count',fontsize=12, color="red")
xp=best_month_tv["month"]
yp=best_month_tv["tvShow_count"]
for i in range(len(yp)):
  plt.annotate(f"month:{xp[i]}",
              xy=(xp[i],yp[i]),
               horizontalalignment="center",fontsize=8)

plt.title('TV Show Count by Month', color="red")
plt.show()

"""**Observation:**

*   The graph indicates that, except for the months of February, May, and June, all other months receive a good number of movie releases. Therefore, we can infer that movies can be released throughout the year.
*   On the other hand, we observe that months such as June, July, September, and December receive the highest number of TV show releases. This suggests that the best time to release TV shows is during the summer and holiday seasons.

**Recommendation:**
* Movies have a good market throughout the year, so high-quality content can always be released. However, we do observe a higher number of releases during holidays. Therefore, with strategic planning and effective promotion, profits can be increased.
* As observed, summer and holidays are the best times to release movies, offering opportunities for increased content releases and profitability.
* Additionally, other seasons can be utilized for TV show releases. We can assume that kids and students are big portion of the audience during summer and holidays, so other seasons can cater to different age groups.

## 4. Analysis of actors/directors of different types of shows/movies.

The top 10 directors who have appeared in most movies or TV shows
"""

df_final.sample()

top10_director = df_final.groupby("director")["title"].nunique().reset_index()
top10_director.rename(columns={"title": "count"}, inplace=True)
# Ignoring the 2634 rows where the "director" column contains "unknown" director.
top10_director_sorted = top10_director.sort_values(by="count", ascending=False)[1:11]
top10_director_sorted

plt.figure(figsize=(8, 6))
x=top10_director_sorted["director"]
y=top10_director_sorted["count"]
plt.bar(x,y)
plt.xticks(rotation=45)
plt.xlabel("Director", fontsize=12,color="red")
plt.ylabel("Count", fontsize=12, color="red")
plt.title("Top 10 Directors (By Count of Movies/Tv Show)", color="red")
plt.show()

"""**Observation:**

*   The graph displays the top 10 directors ranked by the number of movies and TV shows they have produced.
*   The graph illustrates that Rajiv Chilaka has produced the highest number of movies and shows, followed by Jan Suter and Rahul Campos. Interestingly, these directors have produced a similar number of releases.

Recommendations:
* These top directors have the highest number of movies on Netflix. This means that subscribers enjoy the movies by these directors. Netflix can add other projects by these directors to its database, and movies by these directors can also be provided in other languages to reach a larger audience.
* Older movies by these directors can also be added, promoted, and recommended to the audience who enjoy movies by these directors

The top 10 actors who have appeared in most movies or TV shows.
"""

top10_actor=df_final.groupby("cast")["title"].nunique().reset_index()
top10_actor.rename(columns={"title":"count"},inplace=True)
# Ignoring the 825 rows where the "cast" column contains "unknown" actors.
top10_actor_sorted=top10_actor.sort_values(by="count",ascending=False)[1:11]
top10_actor_sorted

plt.figure(figsize=(8, 6))
x=top10_actor_sorted["cast"]
y=top10_actor_sorted["count"]
plt.bar(x,y)
plt.xticks(rotation=45)
plt.xlabel("Actor", fontsize=12,color="red")
plt.ylabel("Count", fontsize=12, color="red")
plt.title("Top 10 Actors (By Count of Movies/Tv Show)", color="red")
plt.show()

"""**Observation:**

*   The graph indicates the top 10 actors based on the number of movies they have on Netflix.
*    Anupam Kher leads the list, followed by Shah Rukh Khan and Ujwala Tejwani. It can be assumed that these actors are among the most watched on Netflix.
*   We can observe that most of the most watched actors are Indian. Therefore, it's reasonable to assume that India has a large number of Netflix users.

**Recommendations** :
* We know Anupam Kher is a renowned actor worldwide, having appeared in numerous Bollywood and Hollywood movies. This could be the reason he tops the list.
* Similarly, Netflix can produce movies with directors and actors who are known worldwide to reach a larger audience. Actors and directors from different industries can create high-quality content that resonates with audiences across multiple nations.
* Promoting and recommending movies featuring these top actors can increase viewership on Netflix.

## 5. Which genre movies are more popular or produced more
"""

from wordcloud import WordCloud
import seaborn as sns
import matplotlib.pyplot as plt

df_final.sample()

df_genre=df_final.groupby("listed_in")["listed_in"].count()

df_genre=pd.DataFrame(df_genre)
df_genre.rename(columns={"listed_in":"count"}, inplace=True)
df_genre.reset_index().sort_values(by="count",ascending=False).head(10)

#converting series to text
genre=" ".join(df_final["listed_in"])

# word cloud
plt.figure(figsize=(10, 8))
wordcloud = WordCloud(width=800, height=400, background_color='Black').generate(genre)

plt.imshow(wordcloud, interpolation='bilinear')
plt.axis('off')
plt.title('Popular Genre', fontsize=14, color="red")
plt.show()

"""**Observation**

*   The graph indicates that dramas top the list, followed by international movies and comedies.
*   Additionally, international TV shows, action & adventure, independent movies, and children & family movies are among the other top contents on Netflix.

Recommendations:

* As we can observe, there are numerous different genres that are liked by various kinds of audiences. Netflix can increase the content of these top categories, which are loved by the audience.
* Drama is the most-watched genre around the world, so Netflix can increase its movie content by adding more movies of a similar genre. Older drama movies can be added to the database, as well as drama movies of foreign languages.

* Data shows that audiences enjoy international content, whether it be movies or TV shows. The more of this content that is available, the more audiences consume it. Therefore, adding top foreign movies and TV shows can increase profits.

## 6. Find After how many days the movie will be added to Netflix after the release of the movie **bold text**
"""

# Defining a function to find out the most recent date a movie was added to Netflix.
def mode_date(x):
  dates=x.mode()
  if not dates.empty:
    return dates.iloc[0]
  return None

mode_dates = df_final.groupby("title")["date_added"].apply(mode_date)

recent_date=mode_dates.reset_index()
recent_date.rename(columns={"date_added":"recent_added_date"},inplace=True)
recent_date["recent_added_date"]=pd.to_datetime(recent_date["recent_added_date"])

# adding colum recent date to original dataframe.
df_final=recent_date.merge(df_final, on="title", how="inner")

df_final.sample()

df_final["recent_added_year"]=df_final["recent_added_date"].dt.year

df_final["time_diff"]=df_final["recent_added_year"]-df_final["release_year"]

df_final.sample(5)

time_diff=df_final.groupby("time_diff")["time_diff"].count()
time_diff=pd.DataFrame(time_diff)
time_diff=time_diff.rename(columns={"time_diff":"count"}).reset_index()

time_diff=time_diff.sort_values(by="count", ascending=False)

time_diff

x=time_diff["time_diff"]
y=time_diff["count"]
plt.bar(x, y)

plt.xlabel('Time Difference in year',fontsize=12, color="red")
plt.xlim(left=0,right=20)
plt.ylabel('No of Movies added', fontsize=12, color="red")
plt.title('The difference between the release date and the date the movie/tv show was added', color="red")

plt.show()

"""**Observation:**

*   The bar graph illustrates that Netflix has added a majority of movies and shows within a year.
*   The data indicates a decreasing difference between the release date and the date when movies are added to the platform.
*   This trend suggests that Netflix is increasingly adding older movies to its collection over time.

**Recommendations:**
* As it can be observed, Netflix is adding more and more older movies to its database. It is recommended to add diverse movies to ensure a varied selection for viewers. This includes adding popular movies from that time period. Regular promotion and recommendation of these older movies are also essential to ensure they reach and engage the audience effectively.

"""

from google.colab import drive
drive.mount('/content/drive')

!sudo apt-get install texlive-xetex texlive-fonts-recommended texlive-plain-generic

!jupyter nbconvert --to pdf /content/drive/MyDrive/Colab Notebooks/Another copy of Netflix case study.ipynb